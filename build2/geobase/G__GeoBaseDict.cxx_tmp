// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME dIhomedImarcidIfair_installdIFairRootdIbuild2dIgeobasedIG__GeoBaseDict

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;

// Header files passed as explicit arguments
#include "FairGeoAssembly.h"
#include "FairGeoCone.h"
#include "FairGeoCons.h"
#include "FairGeoEltu.h"
#include "FairGeoBuilder.h"
#include "FairGeoInterface.h"
#include "FairGeoIo.h"
#include "FairGeoLoader.h"
#include "FairGeoMatrix.h"
#include "FairGeoMedia.h"
#include "FairGeoMedium.h"
#include "FairGeoNode.h"
#include "FairGeoOldAsciiIo.h"
#include "FairGeoPcon.h"
#include "FairGeoPgon.h"
#include "FairGeoRootBuilder.h"
#include "FairGeoRotation.h"
#include "FairGeoSet.h"
#include "FairGeoShapes.h"
#include "FairGeoSphe.h"
#include "FairGeoTransform.h"
#include "FairGeoTrap.h"
#include "FairGeoTrd1.h"
#include "FairGeoTube.h"
#include "FairGeoTubs.h"
#include "FairGeoTorus.h"
#include "FairGeoVector.h"
#include "FairGeoVolume.h"
#include "FairGeoCompositeVolume.h"
#include "FairGeoAsciiIo.h"
#include "FairGeoBrik.h"
#include "FairGeoBasicShape.h"

// Header files passed via #pragma extra_include

namespace ROOT {
   static void *new_FairGeoBasicShape(void *p = 0);
   static void *newArray_FairGeoBasicShape(Long_t size, void *p);
   static void delete_FairGeoBasicShape(void *p);
   static void deleteArray_FairGeoBasicShape(void *p);
   static void destruct_FairGeoBasicShape(void *p);
   static void streamer_FairGeoBasicShape(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoBasicShape*)
   {
      ::FairGeoBasicShape *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoBasicShape >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoBasicShape", ::FairGeoBasicShape::Class_Version(), "FairGeoBasicShape.h", 25,
                  typeid(::FairGeoBasicShape), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoBasicShape::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoBasicShape) );
      instance.SetNew(&new_FairGeoBasicShape);
      instance.SetNewArray(&newArray_FairGeoBasicShape);
      instance.SetDelete(&delete_FairGeoBasicShape);
      instance.SetDeleteArray(&deleteArray_FairGeoBasicShape);
      instance.SetDestructor(&destruct_FairGeoBasicShape);
      instance.SetStreamerFunc(&streamer_FairGeoBasicShape);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoBasicShape*)
   {
      return GenerateInitInstanceLocal((::FairGeoBasicShape*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoBasicShape*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoAssembly(void *p = 0);
   static void *newArray_FairGeoAssembly(Long_t size, void *p);
   static void delete_FairGeoAssembly(void *p);
   static void deleteArray_FairGeoAssembly(void *p);
   static void destruct_FairGeoAssembly(void *p);
   static void streamer_FairGeoAssembly(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoAssembly*)
   {
      ::FairGeoAssembly *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoAssembly >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoAssembly", ::FairGeoAssembly::Class_Version(), "FairGeoAssembly.h", 22,
                  typeid(::FairGeoAssembly), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoAssembly::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoAssembly) );
      instance.SetNew(&new_FairGeoAssembly);
      instance.SetNewArray(&newArray_FairGeoAssembly);
      instance.SetDelete(&delete_FairGeoAssembly);
      instance.SetDeleteArray(&deleteArray_FairGeoAssembly);
      instance.SetDestructor(&destruct_FairGeoAssembly);
      instance.SetStreamerFunc(&streamer_FairGeoAssembly);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoAssembly*)
   {
      return GenerateInitInstanceLocal((::FairGeoAssembly*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoAssembly*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoCone(void *p = 0);
   static void *newArray_FairGeoCone(Long_t size, void *p);
   static void delete_FairGeoCone(void *p);
   static void deleteArray_FairGeoCone(void *p);
   static void destruct_FairGeoCone(void *p);
   static void streamer_FairGeoCone(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoCone*)
   {
      ::FairGeoCone *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoCone >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoCone", ::FairGeoCone::Class_Version(), "FairGeoCone.h", 26,
                  typeid(::FairGeoCone), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoCone::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoCone) );
      instance.SetNew(&new_FairGeoCone);
      instance.SetNewArray(&newArray_FairGeoCone);
      instance.SetDelete(&delete_FairGeoCone);
      instance.SetDeleteArray(&deleteArray_FairGeoCone);
      instance.SetDestructor(&destruct_FairGeoCone);
      instance.SetStreamerFunc(&streamer_FairGeoCone);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoCone*)
   {
      return GenerateInitInstanceLocal((::FairGeoCone*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoCone*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoCons(void *p = 0);
   static void *newArray_FairGeoCons(Long_t size, void *p);
   static void delete_FairGeoCons(void *p);
   static void deleteArray_FairGeoCons(void *p);
   static void destruct_FairGeoCons(void *p);
   static void streamer_FairGeoCons(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoCons*)
   {
      ::FairGeoCons *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoCons >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoCons", ::FairGeoCons::Class_Version(), "FairGeoCons.h", 25,
                  typeid(::FairGeoCons), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoCons::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoCons) );
      instance.SetNew(&new_FairGeoCons);
      instance.SetNewArray(&newArray_FairGeoCons);
      instance.SetDelete(&delete_FairGeoCons);
      instance.SetDeleteArray(&deleteArray_FairGeoCons);
      instance.SetDestructor(&destruct_FairGeoCons);
      instance.SetStreamerFunc(&streamer_FairGeoCons);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoCons*)
   {
      return GenerateInitInstanceLocal((::FairGeoCons*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoCons*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoEltu(void *p = 0);
   static void *newArray_FairGeoEltu(Long_t size, void *p);
   static void delete_FairGeoEltu(void *p);
   static void deleteArray_FairGeoEltu(void *p);
   static void destruct_FairGeoEltu(void *p);
   static void streamer_FairGeoEltu(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoEltu*)
   {
      ::FairGeoEltu *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoEltu >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoEltu", ::FairGeoEltu::Class_Version(), "FairGeoEltu.h", 26,
                  typeid(::FairGeoEltu), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoEltu::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoEltu) );
      instance.SetNew(&new_FairGeoEltu);
      instance.SetNewArray(&newArray_FairGeoEltu);
      instance.SetDelete(&delete_FairGeoEltu);
      instance.SetDeleteArray(&deleteArray_FairGeoEltu);
      instance.SetDestructor(&destruct_FairGeoEltu);
      instance.SetStreamerFunc(&streamer_FairGeoEltu);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoEltu*)
   {
      return GenerateInitInstanceLocal((::FairGeoEltu*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoEltu*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_FairGeoBuilder(void *p);
   static void deleteArray_FairGeoBuilder(void *p);
   static void destruct_FairGeoBuilder(void *p);
   static void streamer_FairGeoBuilder(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoBuilder*)
   {
      ::FairGeoBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoBuilder >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoBuilder", ::FairGeoBuilder::Class_Version(), "FairGeoBuilder.h", 22,
                  typeid(::FairGeoBuilder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoBuilder::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoBuilder) );
      instance.SetDelete(&delete_FairGeoBuilder);
      instance.SetDeleteArray(&deleteArray_FairGeoBuilder);
      instance.SetDestructor(&destruct_FairGeoBuilder);
      instance.SetStreamerFunc(&streamer_FairGeoBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoBuilder*)
   {
      return GenerateInitInstanceLocal((::FairGeoBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoBuilder*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoInterface(void *p = 0);
   static void *newArray_FairGeoInterface(Long_t size, void *p);
   static void delete_FairGeoInterface(void *p);
   static void deleteArray_FairGeoInterface(void *p);
   static void destruct_FairGeoInterface(void *p);
   static void streamer_FairGeoInterface(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoInterface*)
   {
      ::FairGeoInterface *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoInterface >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoInterface", ::FairGeoInterface::Class_Version(), "FairGeoInterface.h", 42,
                  typeid(::FairGeoInterface), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoInterface::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoInterface) );
      instance.SetNew(&new_FairGeoInterface);
      instance.SetNewArray(&newArray_FairGeoInterface);
      instance.SetDelete(&delete_FairGeoInterface);
      instance.SetDeleteArray(&deleteArray_FairGeoInterface);
      instance.SetDestructor(&destruct_FairGeoInterface);
      instance.SetStreamerFunc(&streamer_FairGeoInterface);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoInterface*)
   {
      return GenerateInitInstanceLocal((::FairGeoInterface*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoInterface*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_FairGeoIo(void *p);
   static void deleteArray_FairGeoIo(void *p);
   static void destruct_FairGeoIo(void *p);
   static void streamer_FairGeoIo(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoIo*)
   {
      ::FairGeoIo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoIo >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoIo", ::FairGeoIo::Class_Version(), "FairGeoIo.h", 23,
                  typeid(::FairGeoIo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoIo::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoIo) );
      instance.SetDelete(&delete_FairGeoIo);
      instance.SetDeleteArray(&deleteArray_FairGeoIo);
      instance.SetDestructor(&destruct_FairGeoIo);
      instance.SetStreamerFunc(&streamer_FairGeoIo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoIo*)
   {
      return GenerateInitInstanceLocal((::FairGeoIo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoIo*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoLoader(void *p = 0);
   static void *newArray_FairGeoLoader(Long_t size, void *p);
   static void delete_FairGeoLoader(void *p);
   static void deleteArray_FairGeoLoader(void *p);
   static void destruct_FairGeoLoader(void *p);
   static void streamer_FairGeoLoader(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoLoader*)
   {
      ::FairGeoLoader *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoLoader >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoLoader", ::FairGeoLoader::Class_Version(), "FairGeoLoader.h", 30,
                  typeid(::FairGeoLoader), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoLoader::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoLoader) );
      instance.SetNew(&new_FairGeoLoader);
      instance.SetNewArray(&newArray_FairGeoLoader);
      instance.SetDelete(&delete_FairGeoLoader);
      instance.SetDeleteArray(&deleteArray_FairGeoLoader);
      instance.SetDestructor(&destruct_FairGeoLoader);
      instance.SetStreamerFunc(&streamer_FairGeoLoader);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoLoader*)
   {
      return GenerateInitInstanceLocal((::FairGeoLoader*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoLoader*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoVector(void *p = 0);
   static void *newArray_FairGeoVector(Long_t size, void *p);
   static void delete_FairGeoVector(void *p);
   static void deleteArray_FairGeoVector(void *p);
   static void destruct_FairGeoVector(void *p);
   static void streamer_FairGeoVector(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoVector*)
   {
      ::FairGeoVector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoVector >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoVector", ::FairGeoVector::Class_Version(), "FairGeoVector.h", 21,
                  typeid(::FairGeoVector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoVector::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoVector) );
      instance.SetNew(&new_FairGeoVector);
      instance.SetNewArray(&newArray_FairGeoVector);
      instance.SetDelete(&delete_FairGeoVector);
      instance.SetDeleteArray(&deleteArray_FairGeoVector);
      instance.SetDestructor(&destruct_FairGeoVector);
      instance.SetStreamerFunc(&streamer_FairGeoVector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoVector*)
   {
      return GenerateInitInstanceLocal((::FairGeoVector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoVector*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoMatrix(void *p = 0);
   static void *newArray_FairGeoMatrix(Long_t size, void *p);
   static void delete_FairGeoMatrix(void *p);
   static void deleteArray_FairGeoMatrix(void *p);
   static void destruct_FairGeoMatrix(void *p);
   static void streamer_FairGeoMatrix(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoMatrix*)
   {
      ::FairGeoMatrix *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoMatrix >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoMatrix", ::FairGeoMatrix::Class_Version(), "FairGeoMatrix.h", 20,
                  typeid(::FairGeoMatrix), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoMatrix::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoMatrix) );
      instance.SetNew(&new_FairGeoMatrix);
      instance.SetNewArray(&newArray_FairGeoMatrix);
      instance.SetDelete(&delete_FairGeoMatrix);
      instance.SetDeleteArray(&deleteArray_FairGeoMatrix);
      instance.SetDestructor(&destruct_FairGeoMatrix);
      instance.SetStreamerFunc(&streamer_FairGeoMatrix);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoMatrix*)
   {
      return GenerateInitInstanceLocal((::FairGeoMatrix*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoMatrix*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoMedia(void *p = 0);
   static void *newArray_FairGeoMedia(Long_t size, void *p);
   static void delete_FairGeoMedia(void *p);
   static void deleteArray_FairGeoMedia(void *p);
   static void destruct_FairGeoMedia(void *p);
   static void streamer_FairGeoMedia(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoMedia*)
   {
      ::FairGeoMedia *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoMedia >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoMedia", ::FairGeoMedia::Class_Version(), "FairGeoMedia.h", 26,
                  typeid(::FairGeoMedia), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoMedia::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoMedia) );
      instance.SetNew(&new_FairGeoMedia);
      instance.SetNewArray(&newArray_FairGeoMedia);
      instance.SetDelete(&delete_FairGeoMedia);
      instance.SetDeleteArray(&deleteArray_FairGeoMedia);
      instance.SetDestructor(&destruct_FairGeoMedia);
      instance.SetStreamerFunc(&streamer_FairGeoMedia);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoMedia*)
   {
      return GenerateInitInstanceLocal((::FairGeoMedia*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoMedia*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoMedium(void *p = 0);
   static void *newArray_FairGeoMedium(Long_t size, void *p);
   static void delete_FairGeoMedium(void *p);
   static void deleteArray_FairGeoMedium(void *p);
   static void destruct_FairGeoMedium(void *p);
   static void streamer_FairGeoMedium(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoMedium*)
   {
      ::FairGeoMedium *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoMedium >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoMedium", ::FairGeoMedium::Class_Version(), "FairGeoMedium.h", 22,
                  typeid(::FairGeoMedium), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoMedium::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoMedium) );
      instance.SetNew(&new_FairGeoMedium);
      instance.SetNewArray(&newArray_FairGeoMedium);
      instance.SetDelete(&delete_FairGeoMedium);
      instance.SetDeleteArray(&deleteArray_FairGeoMedium);
      instance.SetDestructor(&destruct_FairGeoMedium);
      instance.SetStreamerFunc(&streamer_FairGeoMedium);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoMedium*)
   {
      return GenerateInitInstanceLocal((::FairGeoMedium*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoMedium*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoRotation(void *p = 0);
   static void *newArray_FairGeoRotation(Long_t size, void *p);
   static void delete_FairGeoRotation(void *p);
   static void deleteArray_FairGeoRotation(void *p);
   static void destruct_FairGeoRotation(void *p);
   static void streamer_FairGeoRotation(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoRotation*)
   {
      ::FairGeoRotation *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoRotation >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoRotation", ::FairGeoRotation::Class_Version(), "FairGeoRotation.h", 26,
                  typeid(::FairGeoRotation), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoRotation::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoRotation) );
      instance.SetNew(&new_FairGeoRotation);
      instance.SetNewArray(&newArray_FairGeoRotation);
      instance.SetDelete(&delete_FairGeoRotation);
      instance.SetDeleteArray(&deleteArray_FairGeoRotation);
      instance.SetDestructor(&destruct_FairGeoRotation);
      instance.SetStreamerFunc(&streamer_FairGeoRotation);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoRotation*)
   {
      return GenerateInitInstanceLocal((::FairGeoRotation*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoRotation*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoTransform(void *p = 0);
   static void *newArray_FairGeoTransform(Long_t size, void *p);
   static void delete_FairGeoTransform(void *p);
   static void deleteArray_FairGeoTransform(void *p);
   static void destruct_FairGeoTransform(void *p);
   static void streamer_FairGeoTransform(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoTransform*)
   {
      ::FairGeoTransform *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoTransform >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoTransform", ::FairGeoTransform::Class_Version(), "FairGeoTransform.h", 21,
                  typeid(::FairGeoTransform), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoTransform::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoTransform) );
      instance.SetNew(&new_FairGeoTransform);
      instance.SetNewArray(&newArray_FairGeoTransform);
      instance.SetDelete(&delete_FairGeoTransform);
      instance.SetDeleteArray(&deleteArray_FairGeoTransform);
      instance.SetDestructor(&destruct_FairGeoTransform);
      instance.SetStreamerFunc(&streamer_FairGeoTransform);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoTransform*)
   {
      return GenerateInitInstanceLocal((::FairGeoTransform*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoTransform*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoVolume(void *p = 0);
   static void *newArray_FairGeoVolume(Long_t size, void *p);
   static void delete_FairGeoVolume(void *p);
   static void deleteArray_FairGeoVolume(void *p);
   static void destruct_FairGeoVolume(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoVolume*)
   {
      ::FairGeoVolume *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoVolume >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoVolume", ::FairGeoVolume::Class_Version(), "FairGeoVolume.h", 27,
                  typeid(::FairGeoVolume), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoVolume::Dictionary, isa_proxy, 4,
                  sizeof(::FairGeoVolume) );
      instance.SetNew(&new_FairGeoVolume);
      instance.SetNewArray(&newArray_FairGeoVolume);
      instance.SetDelete(&delete_FairGeoVolume);
      instance.SetDeleteArray(&deleteArray_FairGeoVolume);
      instance.SetDestructor(&destruct_FairGeoVolume);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoVolume*)
   {
      return GenerateInitInstanceLocal((::FairGeoVolume*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoVolume*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoNode(void *p = 0);
   static void *newArray_FairGeoNode(Long_t size, void *p);
   static void delete_FairGeoNode(void *p);
   static void deleteArray_FairGeoNode(void *p);
   static void destruct_FairGeoNode(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoNode*)
   {
      ::FairGeoNode *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoNode >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoNode", ::FairGeoNode::Class_Version(), "FairGeoNode.h", 42,
                  typeid(::FairGeoNode), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoNode::Dictionary, isa_proxy, 4,
                  sizeof(::FairGeoNode) );
      instance.SetNew(&new_FairGeoNode);
      instance.SetNewArray(&newArray_FairGeoNode);
      instance.SetDelete(&delete_FairGeoNode);
      instance.SetDeleteArray(&deleteArray_FairGeoNode);
      instance.SetDestructor(&destruct_FairGeoNode);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoNode*)
   {
      return GenerateInitInstanceLocal((::FairGeoNode*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoNode*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoOldAsciiIo(void *p = 0);
   static void *newArray_FairGeoOldAsciiIo(Long_t size, void *p);
   static void delete_FairGeoOldAsciiIo(void *p);
   static void deleteArray_FairGeoOldAsciiIo(void *p);
   static void destruct_FairGeoOldAsciiIo(void *p);
   static void streamer_FairGeoOldAsciiIo(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoOldAsciiIo*)
   {
      ::FairGeoOldAsciiIo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoOldAsciiIo >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoOldAsciiIo", ::FairGeoOldAsciiIo::Class_Version(), "FairGeoOldAsciiIo.h", 28,
                  typeid(::FairGeoOldAsciiIo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoOldAsciiIo::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoOldAsciiIo) );
      instance.SetNew(&new_FairGeoOldAsciiIo);
      instance.SetNewArray(&newArray_FairGeoOldAsciiIo);
      instance.SetDelete(&delete_FairGeoOldAsciiIo);
      instance.SetDeleteArray(&deleteArray_FairGeoOldAsciiIo);
      instance.SetDestructor(&destruct_FairGeoOldAsciiIo);
      instance.SetStreamerFunc(&streamer_FairGeoOldAsciiIo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoOldAsciiIo*)
   {
      return GenerateInitInstanceLocal((::FairGeoOldAsciiIo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoOldAsciiIo*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoPcon(void *p = 0);
   static void *newArray_FairGeoPcon(Long_t size, void *p);
   static void delete_FairGeoPcon(void *p);
   static void deleteArray_FairGeoPcon(void *p);
   static void destruct_FairGeoPcon(void *p);
   static void streamer_FairGeoPcon(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoPcon*)
   {
      ::FairGeoPcon *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoPcon >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoPcon", ::FairGeoPcon::Class_Version(), "FairGeoPcon.h", 26,
                  typeid(::FairGeoPcon), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoPcon::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoPcon) );
      instance.SetNew(&new_FairGeoPcon);
      instance.SetNewArray(&newArray_FairGeoPcon);
      instance.SetDelete(&delete_FairGeoPcon);
      instance.SetDeleteArray(&deleteArray_FairGeoPcon);
      instance.SetDestructor(&destruct_FairGeoPcon);
      instance.SetStreamerFunc(&streamer_FairGeoPcon);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoPcon*)
   {
      return GenerateInitInstanceLocal((::FairGeoPcon*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoPcon*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoPgon(void *p = 0);
   static void *newArray_FairGeoPgon(Long_t size, void *p);
   static void delete_FairGeoPgon(void *p);
   static void deleteArray_FairGeoPgon(void *p);
   static void destruct_FairGeoPgon(void *p);
   static void streamer_FairGeoPgon(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoPgon*)
   {
      ::FairGeoPgon *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoPgon >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoPgon", ::FairGeoPgon::Class_Version(), "FairGeoPgon.h", 26,
                  typeid(::FairGeoPgon), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoPgon::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoPgon) );
      instance.SetNew(&new_FairGeoPgon);
      instance.SetNewArray(&newArray_FairGeoPgon);
      instance.SetDelete(&delete_FairGeoPgon);
      instance.SetDeleteArray(&deleteArray_FairGeoPgon);
      instance.SetDestructor(&destruct_FairGeoPgon);
      instance.SetStreamerFunc(&streamer_FairGeoPgon);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoPgon*)
   {
      return GenerateInitInstanceLocal((::FairGeoPgon*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoPgon*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoRootBuilder(void *p = 0);
   static void *newArray_FairGeoRootBuilder(Long_t size, void *p);
   static void delete_FairGeoRootBuilder(void *p);
   static void deleteArray_FairGeoRootBuilder(void *p);
   static void destruct_FairGeoRootBuilder(void *p);
   static void streamer_FairGeoRootBuilder(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoRootBuilder*)
   {
      ::FairGeoRootBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoRootBuilder >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoRootBuilder", ::FairGeoRootBuilder::Class_Version(), "FairGeoRootBuilder.h", 23,
                  typeid(::FairGeoRootBuilder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoRootBuilder::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoRootBuilder) );
      instance.SetNew(&new_FairGeoRootBuilder);
      instance.SetNewArray(&newArray_FairGeoRootBuilder);
      instance.SetDelete(&delete_FairGeoRootBuilder);
      instance.SetDeleteArray(&deleteArray_FairGeoRootBuilder);
      instance.SetDestructor(&destruct_FairGeoRootBuilder);
      instance.SetStreamerFunc(&streamer_FairGeoRootBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoRootBuilder*)
   {
      return GenerateInitInstanceLocal((::FairGeoRootBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoRootBuilder*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_FairGeoSet(void *p);
   static void deleteArray_FairGeoSet(void *p);
   static void destruct_FairGeoSet(void *p);
   static void streamer_FairGeoSet(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoSet*)
   {
      ::FairGeoSet *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoSet >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoSet", ::FairGeoSet::Class_Version(), "FairGeoSet.h", 33,
                  typeid(::FairGeoSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoSet::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoSet) );
      instance.SetDelete(&delete_FairGeoSet);
      instance.SetDeleteArray(&deleteArray_FairGeoSet);
      instance.SetDestructor(&destruct_FairGeoSet);
      instance.SetStreamerFunc(&streamer_FairGeoSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoSet*)
   {
      return GenerateInitInstanceLocal((::FairGeoSet*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoSet*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoShapes(void *p = 0);
   static void *newArray_FairGeoShapes(Long_t size, void *p);
   static void delete_FairGeoShapes(void *p);
   static void deleteArray_FairGeoShapes(void *p);
   static void destruct_FairGeoShapes(void *p);
   static void streamer_FairGeoShapes(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoShapes*)
   {
      ::FairGeoShapes *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoShapes >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoShapes", ::FairGeoShapes::Class_Version(), "FairGeoShapes.h", 26,
                  typeid(::FairGeoShapes), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoShapes::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoShapes) );
      instance.SetNew(&new_FairGeoShapes);
      instance.SetNewArray(&newArray_FairGeoShapes);
      instance.SetDelete(&delete_FairGeoShapes);
      instance.SetDeleteArray(&deleteArray_FairGeoShapes);
      instance.SetDestructor(&destruct_FairGeoShapes);
      instance.SetStreamerFunc(&streamer_FairGeoShapes);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoShapes*)
   {
      return GenerateInitInstanceLocal((::FairGeoShapes*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoShapes*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoSphe(void *p = 0);
   static void *newArray_FairGeoSphe(Long_t size, void *p);
   static void delete_FairGeoSphe(void *p);
   static void deleteArray_FairGeoSphe(void *p);
   static void destruct_FairGeoSphe(void *p);
   static void streamer_FairGeoSphe(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoSphe*)
   {
      ::FairGeoSphe *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoSphe >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoSphe", ::FairGeoSphe::Class_Version(), "FairGeoSphe.h", 26,
                  typeid(::FairGeoSphe), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoSphe::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoSphe) );
      instance.SetNew(&new_FairGeoSphe);
      instance.SetNewArray(&newArray_FairGeoSphe);
      instance.SetDelete(&delete_FairGeoSphe);
      instance.SetDeleteArray(&deleteArray_FairGeoSphe);
      instance.SetDestructor(&destruct_FairGeoSphe);
      instance.SetStreamerFunc(&streamer_FairGeoSphe);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoSphe*)
   {
      return GenerateInitInstanceLocal((::FairGeoSphe*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoSphe*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoTrap(void *p = 0);
   static void *newArray_FairGeoTrap(Long_t size, void *p);
   static void delete_FairGeoTrap(void *p);
   static void deleteArray_FairGeoTrap(void *p);
   static void destruct_FairGeoTrap(void *p);
   static void streamer_FairGeoTrap(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoTrap*)
   {
      ::FairGeoTrap *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoTrap >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoTrap", ::FairGeoTrap::Class_Version(), "FairGeoTrap.h", 21,
                  typeid(::FairGeoTrap), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoTrap::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoTrap) );
      instance.SetNew(&new_FairGeoTrap);
      instance.SetNewArray(&newArray_FairGeoTrap);
      instance.SetDelete(&delete_FairGeoTrap);
      instance.SetDeleteArray(&deleteArray_FairGeoTrap);
      instance.SetDestructor(&destruct_FairGeoTrap);
      instance.SetStreamerFunc(&streamer_FairGeoTrap);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoTrap*)
   {
      return GenerateInitInstanceLocal((::FairGeoTrap*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoTrap*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoTrd1(void *p = 0);
   static void *newArray_FairGeoTrd1(Long_t size, void *p);
   static void delete_FairGeoTrd1(void *p);
   static void deleteArray_FairGeoTrd1(void *p);
   static void destruct_FairGeoTrd1(void *p);
   static void streamer_FairGeoTrd1(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoTrd1*)
   {
      ::FairGeoTrd1 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoTrd1 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoTrd1", ::FairGeoTrd1::Class_Version(), "FairGeoTrd1.h", 21,
                  typeid(::FairGeoTrd1), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoTrd1::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoTrd1) );
      instance.SetNew(&new_FairGeoTrd1);
      instance.SetNewArray(&newArray_FairGeoTrd1);
      instance.SetDelete(&delete_FairGeoTrd1);
      instance.SetDeleteArray(&deleteArray_FairGeoTrd1);
      instance.SetDestructor(&destruct_FairGeoTrd1);
      instance.SetStreamerFunc(&streamer_FairGeoTrd1);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoTrd1*)
   {
      return GenerateInitInstanceLocal((::FairGeoTrd1*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoTrd1*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoTube(void *p = 0);
   static void *newArray_FairGeoTube(Long_t size, void *p);
   static void delete_FairGeoTube(void *p);
   static void deleteArray_FairGeoTube(void *p);
   static void destruct_FairGeoTube(void *p);
   static void streamer_FairGeoTube(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoTube*)
   {
      ::FairGeoTube *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoTube >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoTube", ::FairGeoTube::Class_Version(), "FairGeoTube.h", 22,
                  typeid(::FairGeoTube), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoTube::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoTube) );
      instance.SetNew(&new_FairGeoTube);
      instance.SetNewArray(&newArray_FairGeoTube);
      instance.SetDelete(&delete_FairGeoTube);
      instance.SetDeleteArray(&deleteArray_FairGeoTube);
      instance.SetDestructor(&destruct_FairGeoTube);
      instance.SetStreamerFunc(&streamer_FairGeoTube);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoTube*)
   {
      return GenerateInitInstanceLocal((::FairGeoTube*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoTube*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoTubs(void *p = 0);
   static void *newArray_FairGeoTubs(Long_t size, void *p);
   static void delete_FairGeoTubs(void *p);
   static void deleteArray_FairGeoTubs(void *p);
   static void destruct_FairGeoTubs(void *p);
   static void streamer_FairGeoTubs(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoTubs*)
   {
      ::FairGeoTubs *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoTubs >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoTubs", ::FairGeoTubs::Class_Version(), "FairGeoTubs.h", 22,
                  typeid(::FairGeoTubs), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoTubs::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoTubs) );
      instance.SetNew(&new_FairGeoTubs);
      instance.SetNewArray(&newArray_FairGeoTubs);
      instance.SetDelete(&delete_FairGeoTubs);
      instance.SetDeleteArray(&deleteArray_FairGeoTubs);
      instance.SetDestructor(&destruct_FairGeoTubs);
      instance.SetStreamerFunc(&streamer_FairGeoTubs);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoTubs*)
   {
      return GenerateInitInstanceLocal((::FairGeoTubs*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoTubs*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoTorus(void *p = 0);
   static void *newArray_FairGeoTorus(Long_t size, void *p);
   static void delete_FairGeoTorus(void *p);
   static void deleteArray_FairGeoTorus(void *p);
   static void destruct_FairGeoTorus(void *p);
   static void streamer_FairGeoTorus(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoTorus*)
   {
      ::FairGeoTorus *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoTorus >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoTorus", ::FairGeoTorus::Class_Version(), "FairGeoTorus.h", 22,
                  typeid(::FairGeoTorus), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoTorus::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoTorus) );
      instance.SetNew(&new_FairGeoTorus);
      instance.SetNewArray(&newArray_FairGeoTorus);
      instance.SetDelete(&delete_FairGeoTorus);
      instance.SetDeleteArray(&deleteArray_FairGeoTorus);
      instance.SetDestructor(&destruct_FairGeoTorus);
      instance.SetStreamerFunc(&streamer_FairGeoTorus);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoTorus*)
   {
      return GenerateInitInstanceLocal((::FairGeoTorus*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoTorus*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoCompositeVolume(void *p = 0);
   static void *newArray_FairGeoCompositeVolume(Long_t size, void *p);
   static void delete_FairGeoCompositeVolume(void *p);
   static void deleteArray_FairGeoCompositeVolume(void *p);
   static void destruct_FairGeoCompositeVolume(void *p);
   static void streamer_FairGeoCompositeVolume(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoCompositeVolume*)
   {
      ::FairGeoCompositeVolume *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoCompositeVolume >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoCompositeVolume", ::FairGeoCompositeVolume::Class_Version(), "FairGeoCompositeVolume.h", 20,
                  typeid(::FairGeoCompositeVolume), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoCompositeVolume::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoCompositeVolume) );
      instance.SetNew(&new_FairGeoCompositeVolume);
      instance.SetNewArray(&newArray_FairGeoCompositeVolume);
      instance.SetDelete(&delete_FairGeoCompositeVolume);
      instance.SetDeleteArray(&deleteArray_FairGeoCompositeVolume);
      instance.SetDestructor(&destruct_FairGeoCompositeVolume);
      instance.SetStreamerFunc(&streamer_FairGeoCompositeVolume);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoCompositeVolume*)
   {
      return GenerateInitInstanceLocal((::FairGeoCompositeVolume*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoCompositeVolume*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoAsciiIo(void *p = 0);
   static void *newArray_FairGeoAsciiIo(Long_t size, void *p);
   static void delete_FairGeoAsciiIo(void *p);
   static void deleteArray_FairGeoAsciiIo(void *p);
   static void destruct_FairGeoAsciiIo(void *p);
   static void streamer_FairGeoAsciiIo(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoAsciiIo*)
   {
      ::FairGeoAsciiIo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoAsciiIo >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoAsciiIo", ::FairGeoAsciiIo::Class_Version(), "FairGeoAsciiIo.h", 27,
                  typeid(::FairGeoAsciiIo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoAsciiIo::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoAsciiIo) );
      instance.SetNew(&new_FairGeoAsciiIo);
      instance.SetNewArray(&newArray_FairGeoAsciiIo);
      instance.SetDelete(&delete_FairGeoAsciiIo);
      instance.SetDeleteArray(&deleteArray_FairGeoAsciiIo);
      instance.SetDestructor(&destruct_FairGeoAsciiIo);
      instance.SetStreamerFunc(&streamer_FairGeoAsciiIo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoAsciiIo*)
   {
      return GenerateInitInstanceLocal((::FairGeoAsciiIo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoAsciiIo*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_FairGeoBrik(void *p = 0);
   static void *newArray_FairGeoBrik(Long_t size, void *p);
   static void delete_FairGeoBrik(void *p);
   static void deleteArray_FairGeoBrik(void *p);
   static void destruct_FairGeoBrik(void *p);
   static void streamer_FairGeoBrik(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FairGeoBrik*)
   {
      ::FairGeoBrik *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::FairGeoBrik >(0);
      static ::ROOT::TGenericClassInfo 
         instance("FairGeoBrik", ::FairGeoBrik::Class_Version(), "FairGeoBrik.h", 20,
                  typeid(::FairGeoBrik), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::FairGeoBrik::Dictionary, isa_proxy, 16,
                  sizeof(::FairGeoBrik) );
      instance.SetNew(&new_FairGeoBrik);
      instance.SetNewArray(&newArray_FairGeoBrik);
      instance.SetDelete(&delete_FairGeoBrik);
      instance.SetDeleteArray(&deleteArray_FairGeoBrik);
      instance.SetDestructor(&destruct_FairGeoBrik);
      instance.SetStreamerFunc(&streamer_FairGeoBrik);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FairGeoBrik*)
   {
      return GenerateInitInstanceLocal((::FairGeoBrik*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FairGeoBrik*)0x0); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

//______________________________________________________________________________
atomic_TClass_ptr FairGeoBasicShape::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoBasicShape::Class_Name()
{
   return "FairGeoBasicShape";
}

//______________________________________________________________________________
const char *FairGeoBasicShape::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBasicShape*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoBasicShape::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBasicShape*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoBasicShape::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBasicShape*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoBasicShape::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBasicShape*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoAssembly::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoAssembly::Class_Name()
{
   return "FairGeoAssembly";
}

//______________________________________________________________________________
const char *FairGeoAssembly::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAssembly*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoAssembly::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAssembly*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoAssembly::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAssembly*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoAssembly::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAssembly*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoCone::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoCone::Class_Name()
{
   return "FairGeoCone";
}

//______________________________________________________________________________
const char *FairGeoCone::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCone*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoCone::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCone*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoCone::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCone*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoCone::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCone*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoCons::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoCons::Class_Name()
{
   return "FairGeoCons";
}

//______________________________________________________________________________
const char *FairGeoCons::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCons*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoCons::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCons*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoCons::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCons*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoCons::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCons*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoEltu::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoEltu::Class_Name()
{
   return "FairGeoEltu";
}

//______________________________________________________________________________
const char *FairGeoEltu::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoEltu*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoEltu::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoEltu*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoEltu::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoEltu*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoEltu::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoEltu*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoBuilder::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoBuilder::Class_Name()
{
   return "FairGeoBuilder";
}

//______________________________________________________________________________
const char *FairGeoBuilder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBuilder*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoBuilder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBuilder*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoBuilder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBuilder*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoBuilder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBuilder*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoInterface::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoInterface::Class_Name()
{
   return "FairGeoInterface";
}

//______________________________________________________________________________
const char *FairGeoInterface::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoInterface*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoInterface::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoInterface*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoInterface::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoInterface*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoInterface::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoInterface*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoIo::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoIo::Class_Name()
{
   return "FairGeoIo";
}

//______________________________________________________________________________
const char *FairGeoIo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoIo*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoIo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoIo*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoIo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoIo*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoIo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoIo*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoLoader::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoLoader::Class_Name()
{
   return "FairGeoLoader";
}

//______________________________________________________________________________
const char *FairGeoLoader::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoLoader*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoLoader::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoLoader*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoLoader::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoLoader*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoLoader::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoLoader*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoVector::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoVector::Class_Name()
{
   return "FairGeoVector";
}

//______________________________________________________________________________
const char *FairGeoVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVector*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoVector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVector*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoMatrix::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoMatrix::Class_Name()
{
   return "FairGeoMatrix";
}

//______________________________________________________________________________
const char *FairGeoMatrix::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMatrix*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoMatrix::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMatrix*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoMatrix::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMatrix*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoMatrix::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMatrix*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoMedia::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoMedia::Class_Name()
{
   return "FairGeoMedia";
}

//______________________________________________________________________________
const char *FairGeoMedia::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedia*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoMedia::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedia*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoMedia::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedia*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoMedia::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedia*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoMedium::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoMedium::Class_Name()
{
   return "FairGeoMedium";
}

//______________________________________________________________________________
const char *FairGeoMedium::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedium*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoMedium::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedium*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoMedium::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedium*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoMedium::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoMedium*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoRotation::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoRotation::Class_Name()
{
   return "FairGeoRotation";
}

//______________________________________________________________________________
const char *FairGeoRotation::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRotation*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoRotation::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRotation*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoRotation::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRotation*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoRotation::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRotation*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoTransform::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoTransform::Class_Name()
{
   return "FairGeoTransform";
}

//______________________________________________________________________________
const char *FairGeoTransform::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTransform*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoTransform::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTransform*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoTransform::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTransform*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoTransform::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTransform*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoVolume::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoVolume::Class_Name()
{
   return "FairGeoVolume";
}

//______________________________________________________________________________
const char *FairGeoVolume::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVolume*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoVolume::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVolume*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoVolume::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVolume*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoVolume::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoVolume*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoNode::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoNode::Class_Name()
{
   return "FairGeoNode";
}

//______________________________________________________________________________
const char *FairGeoNode::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoNode*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoNode::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoNode*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoNode::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoNode*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoNode::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoNode*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoOldAsciiIo::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoOldAsciiIo::Class_Name()
{
   return "FairGeoOldAsciiIo";
}

//______________________________________________________________________________
const char *FairGeoOldAsciiIo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoOldAsciiIo*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoOldAsciiIo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoOldAsciiIo*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoOldAsciiIo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoOldAsciiIo*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoOldAsciiIo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoOldAsciiIo*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoPcon::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoPcon::Class_Name()
{
   return "FairGeoPcon";
}

//______________________________________________________________________________
const char *FairGeoPcon::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPcon*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoPcon::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPcon*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoPcon::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPcon*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoPcon::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPcon*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoPgon::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoPgon::Class_Name()
{
   return "FairGeoPgon";
}

//______________________________________________________________________________
const char *FairGeoPgon::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPgon*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoPgon::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPgon*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoPgon::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPgon*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoPgon::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoPgon*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoRootBuilder::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoRootBuilder::Class_Name()
{
   return "FairGeoRootBuilder";
}

//______________________________________________________________________________
const char *FairGeoRootBuilder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRootBuilder*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoRootBuilder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRootBuilder*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoRootBuilder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRootBuilder*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoRootBuilder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoRootBuilder*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoSet::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoSet::Class_Name()
{
   return "FairGeoSet";
}

//______________________________________________________________________________
const char *FairGeoSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSet*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSet*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSet*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSet*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoShapes::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoShapes::Class_Name()
{
   return "FairGeoShapes";
}

//______________________________________________________________________________
const char *FairGeoShapes::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoShapes*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoShapes::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoShapes*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoShapes::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoShapes*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoShapes::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoShapes*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoSphe::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoSphe::Class_Name()
{
   return "FairGeoSphe";
}

//______________________________________________________________________________
const char *FairGeoSphe::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSphe*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoSphe::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSphe*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoSphe::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSphe*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoSphe::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoSphe*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoTrap::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoTrap::Class_Name()
{
   return "FairGeoTrap";
}

//______________________________________________________________________________
const char *FairGeoTrap::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrap*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoTrap::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrap*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoTrap::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrap*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoTrap::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrap*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoTrd1::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoTrd1::Class_Name()
{
   return "FairGeoTrd1";
}

//______________________________________________________________________________
const char *FairGeoTrd1::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrd1*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoTrd1::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrd1*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoTrd1::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrd1*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoTrd1::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTrd1*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoTube::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoTube::Class_Name()
{
   return "FairGeoTube";
}

//______________________________________________________________________________
const char *FairGeoTube::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTube*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoTube::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTube*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoTube::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTube*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoTube::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTube*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoTubs::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoTubs::Class_Name()
{
   return "FairGeoTubs";
}

//______________________________________________________________________________
const char *FairGeoTubs::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTubs*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoTubs::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTubs*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoTubs::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTubs*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoTubs::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTubs*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoTorus::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoTorus::Class_Name()
{
   return "FairGeoTorus";
}

//______________________________________________________________________________
const char *FairGeoTorus::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTorus*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoTorus::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTorus*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoTorus::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTorus*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoTorus::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoTorus*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoCompositeVolume::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoCompositeVolume::Class_Name()
{
   return "FairGeoCompositeVolume";
}

//______________________________________________________________________________
const char *FairGeoCompositeVolume::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCompositeVolume*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoCompositeVolume::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCompositeVolume*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoCompositeVolume::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCompositeVolume*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoCompositeVolume::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoCompositeVolume*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoAsciiIo::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoAsciiIo::Class_Name()
{
   return "FairGeoAsciiIo";
}

//______________________________________________________________________________
const char *FairGeoAsciiIo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAsciiIo*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoAsciiIo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAsciiIo*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoAsciiIo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAsciiIo*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoAsciiIo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoAsciiIo*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr FairGeoBrik::fgIsA(0);  // static to hold class pointer

//______________________________________________________________________________
const char *FairGeoBrik::Class_Name()
{
   return "FairGeoBrik";
}

//______________________________________________________________________________
const char *FairGeoBrik::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBrik*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int FairGeoBrik::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBrik*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *FairGeoBrik::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBrik*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *FairGeoBrik::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD2(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::FairGeoBrik*)0x0)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
void FairGeoBasicShape::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoBasicShape.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoBasicShape(void *p) {
      return  p ? new(p) ::FairGeoBasicShape : new ::FairGeoBasicShape;
   }
   static void *newArray_FairGeoBasicShape(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoBasicShape[nElements] : new ::FairGeoBasicShape[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoBasicShape(void *p) {
      delete ((::FairGeoBasicShape*)p);
   }
   static void deleteArray_FairGeoBasicShape(void *p) {
      delete [] ((::FairGeoBasicShape*)p);
   }
   static void destruct_FairGeoBasicShape(void *p) {
      typedef ::FairGeoBasicShape current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoBasicShape(TBuffer &buf, void *obj) {
      ((::FairGeoBasicShape*)obj)->::FairGeoBasicShape::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoBasicShape

//______________________________________________________________________________
void FairGeoAssembly::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoAssembly.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoAssembly(void *p) {
      return  p ? new(p) ::FairGeoAssembly : new ::FairGeoAssembly;
   }
   static void *newArray_FairGeoAssembly(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoAssembly[nElements] : new ::FairGeoAssembly[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoAssembly(void *p) {
      delete ((::FairGeoAssembly*)p);
   }
   static void deleteArray_FairGeoAssembly(void *p) {
      delete [] ((::FairGeoAssembly*)p);
   }
   static void destruct_FairGeoAssembly(void *p) {
      typedef ::FairGeoAssembly current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoAssembly(TBuffer &buf, void *obj) {
      ((::FairGeoAssembly*)obj)->::FairGeoAssembly::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoAssembly

//______________________________________________________________________________
void FairGeoCone::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoCone.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoCone(void *p) {
      return  p ? new(p) ::FairGeoCone : new ::FairGeoCone;
   }
   static void *newArray_FairGeoCone(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoCone[nElements] : new ::FairGeoCone[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoCone(void *p) {
      delete ((::FairGeoCone*)p);
   }
   static void deleteArray_FairGeoCone(void *p) {
      delete [] ((::FairGeoCone*)p);
   }
   static void destruct_FairGeoCone(void *p) {
      typedef ::FairGeoCone current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoCone(TBuffer &buf, void *obj) {
      ((::FairGeoCone*)obj)->::FairGeoCone::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoCone

//______________________________________________________________________________
void FairGeoCons::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoCons.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoCons(void *p) {
      return  p ? new(p) ::FairGeoCons : new ::FairGeoCons;
   }
   static void *newArray_FairGeoCons(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoCons[nElements] : new ::FairGeoCons[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoCons(void *p) {
      delete ((::FairGeoCons*)p);
   }
   static void deleteArray_FairGeoCons(void *p) {
      delete [] ((::FairGeoCons*)p);
   }
   static void destruct_FairGeoCons(void *p) {
      typedef ::FairGeoCons current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoCons(TBuffer &buf, void *obj) {
      ((::FairGeoCons*)obj)->::FairGeoCons::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoCons

//______________________________________________________________________________
void FairGeoEltu::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoEltu.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoEltu(void *p) {
      return  p ? new(p) ::FairGeoEltu : new ::FairGeoEltu;
   }
   static void *newArray_FairGeoEltu(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoEltu[nElements] : new ::FairGeoEltu[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoEltu(void *p) {
      delete ((::FairGeoEltu*)p);
   }
   static void deleteArray_FairGeoEltu(void *p) {
      delete [] ((::FairGeoEltu*)p);
   }
   static void destruct_FairGeoEltu(void *p) {
      typedef ::FairGeoEltu current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoEltu(TBuffer &buf, void *obj) {
      ((::FairGeoEltu*)obj)->::FairGeoEltu::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoEltu

//______________________________________________________________________________
void FairGeoBuilder::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoBuilder.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_FairGeoBuilder(void *p) {
      delete ((::FairGeoBuilder*)p);
   }
   static void deleteArray_FairGeoBuilder(void *p) {
      delete [] ((::FairGeoBuilder*)p);
   }
   static void destruct_FairGeoBuilder(void *p) {
      typedef ::FairGeoBuilder current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoBuilder(TBuffer &buf, void *obj) {
      ((::FairGeoBuilder*)obj)->::FairGeoBuilder::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoBuilder

//______________________________________________________________________________
void FairGeoInterface::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoInterface.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoInterface(void *p) {
      return  p ? new(p) ::FairGeoInterface : new ::FairGeoInterface;
   }
   static void *newArray_FairGeoInterface(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoInterface[nElements] : new ::FairGeoInterface[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoInterface(void *p) {
      delete ((::FairGeoInterface*)p);
   }
   static void deleteArray_FairGeoInterface(void *p) {
      delete [] ((::FairGeoInterface*)p);
   }
   static void destruct_FairGeoInterface(void *p) {
      typedef ::FairGeoInterface current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoInterface(TBuffer &buf, void *obj) {
      ((::FairGeoInterface*)obj)->::FairGeoInterface::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoInterface

//______________________________________________________________________________
void FairGeoIo::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoIo.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_FairGeoIo(void *p) {
      delete ((::FairGeoIo*)p);
   }
   static void deleteArray_FairGeoIo(void *p) {
      delete [] ((::FairGeoIo*)p);
   }
   static void destruct_FairGeoIo(void *p) {
      typedef ::FairGeoIo current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoIo(TBuffer &buf, void *obj) {
      ((::FairGeoIo*)obj)->::FairGeoIo::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoIo

//______________________________________________________________________________
void FairGeoLoader::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoLoader.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TNamed::Streamer(R__b);
      R__b.CheckByteCount(R__s, R__c, FairGeoLoader::IsA());
   } else {
      R__c = R__b.WriteVersion(FairGeoLoader::IsA(), kTRUE);
      TNamed::Streamer(R__b);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoLoader(void *p) {
      return  p ? new(p) ::FairGeoLoader : new ::FairGeoLoader;
   }
   static void *newArray_FairGeoLoader(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoLoader[nElements] : new ::FairGeoLoader[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoLoader(void *p) {
      delete ((::FairGeoLoader*)p);
   }
   static void deleteArray_FairGeoLoader(void *p) {
      delete [] ((::FairGeoLoader*)p);
   }
   static void destruct_FairGeoLoader(void *p) {
      typedef ::FairGeoLoader current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoLoader(TBuffer &buf, void *obj) {
      ((::FairGeoLoader*)obj)->::FairGeoLoader::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoLoader

//______________________________________________________________________________
void FairGeoVector::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoVector.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      R__b >> x;
      R__b >> y;
      R__b >> z;
      R__b.CheckByteCount(R__s, R__c, FairGeoVector::IsA());
   } else {
      R__c = R__b.WriteVersion(FairGeoVector::IsA(), kTRUE);
      TObject::Streamer(R__b);
      R__b << x;
      R__b << y;
      R__b << z;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoVector(void *p) {
      return  p ? new(p) ::FairGeoVector : new ::FairGeoVector;
   }
   static void *newArray_FairGeoVector(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoVector[nElements] : new ::FairGeoVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoVector(void *p) {
      delete ((::FairGeoVector*)p);
   }
   static void deleteArray_FairGeoVector(void *p) {
      delete [] ((::FairGeoVector*)p);
   }
   static void destruct_FairGeoVector(void *p) {
      typedef ::FairGeoVector current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoVector(TBuffer &buf, void *obj) {
      ((::FairGeoVector*)obj)->::FairGeoVector::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoVector

//______________________________________________________________________________
void FairGeoMatrix::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoMatrix.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoMatrix(void *p) {
      return  p ? new(p) ::FairGeoMatrix : new ::FairGeoMatrix;
   }
   static void *newArray_FairGeoMatrix(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoMatrix[nElements] : new ::FairGeoMatrix[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoMatrix(void *p) {
      delete ((::FairGeoMatrix*)p);
   }
   static void deleteArray_FairGeoMatrix(void *p) {
      delete [] ((::FairGeoMatrix*)p);
   }
   static void destruct_FairGeoMatrix(void *p) {
      typedef ::FairGeoMatrix current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoMatrix(TBuffer &buf, void *obj) {
      ((::FairGeoMatrix*)obj)->::FairGeoMatrix::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoMatrix

//______________________________________________________________________________
void FairGeoMedia::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoMedia.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoMedia(void *p) {
      return  p ? new(p) ::FairGeoMedia : new ::FairGeoMedia;
   }
   static void *newArray_FairGeoMedia(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoMedia[nElements] : new ::FairGeoMedia[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoMedia(void *p) {
      delete ((::FairGeoMedia*)p);
   }
   static void deleteArray_FairGeoMedia(void *p) {
      delete [] ((::FairGeoMedia*)p);
   }
   static void destruct_FairGeoMedia(void *p) {
      typedef ::FairGeoMedia current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoMedia(TBuffer &buf, void *obj) {
      ((::FairGeoMedia*)obj)->::FairGeoMedia::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoMedia

//______________________________________________________________________________
void FairGeoMedium::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoMedium.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TNamed::Streamer(R__b);
      R__b >> medId;
      R__b >> autoflag;
      R__b >> nComponents;
      R__b >> weightFac;
      delete [] ca;
      ca = new Double_t[nComponents];
      R__b.ReadFastArray(ca,nComponents);
      delete [] cz;
      cz = new Double_t[nComponents];
      R__b.ReadFastArray(cz,nComponents);
      delete [] cw;
      cw = new Double_t[nComponents];
      R__b.ReadFastArray(cw,nComponents);
      R__b >> density;
      R__b >> radLen;
      R__b >> sensFlag;
      R__b >> fldFlag;
      R__b >> fld;
      R__b >> epsil;
      R__b >> madfld;
      R__b >> maxstep;
      R__b >> maxde;
      R__b >> minstep;
      R__b >> npckov;
      delete [] ppckov;
      ppckov = new Double_t[npckov];
      R__b.ReadFastArray(ppckov,npckov);
      delete [] absco;
      absco = new Double_t[npckov];
      R__b.ReadFastArray(absco,npckov);
      delete [] effic;
      effic = new Double_t[npckov];
      R__b.ReadFastArray(effic,npckov);
      delete [] rindex;
      rindex = new Double_t[npckov];
      R__b.ReadFastArray(rindex,npckov);
      R__b.CheckByteCount(R__s, R__c, FairGeoMedium::IsA());
   } else {
      R__c = R__b.WriteVersion(FairGeoMedium::IsA(), kTRUE);
      TNamed::Streamer(R__b);
      R__b << medId;
      R__b << autoflag;
      R__b << nComponents;
      R__b << weightFac;
      R__b.WriteFastArray(ca,nComponents);
      R__b.WriteFastArray(cz,nComponents);
      R__b.WriteFastArray(cw,nComponents);
      R__b << density;
      R__b << radLen;
      R__b << sensFlag;
      R__b << fldFlag;
      R__b << fld;
      R__b << epsil;
      R__b << madfld;
      R__b << maxstep;
      R__b << maxde;
      R__b << minstep;
      R__b << npckov;
      R__b.WriteFastArray(ppckov,npckov);
      R__b.WriteFastArray(absco,npckov);
      R__b.WriteFastArray(effic,npckov);
      R__b.WriteFastArray(rindex,npckov);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoMedium(void *p) {
      return  p ? new(p) ::FairGeoMedium : new ::FairGeoMedium;
   }
   static void *newArray_FairGeoMedium(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoMedium[nElements] : new ::FairGeoMedium[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoMedium(void *p) {
      delete ((::FairGeoMedium*)p);
   }
   static void deleteArray_FairGeoMedium(void *p) {
      delete [] ((::FairGeoMedium*)p);
   }
   static void destruct_FairGeoMedium(void *p) {
      typedef ::FairGeoMedium current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoMedium(TBuffer &buf, void *obj) {
      ((::FairGeoMedium*)obj)->::FairGeoMedium::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoMedium

//______________________________________________________________________________
void FairGeoRotation::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoRotation.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      R__b.ReadStaticArray((double*)rot);
      R__b.CheckByteCount(R__s, R__c, FairGeoRotation::IsA());
   } else {
      R__c = R__b.WriteVersion(FairGeoRotation::IsA(), kTRUE);
      TObject::Streamer(R__b);
      R__b.WriteArray(rot, 9);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoRotation(void *p) {
      return  p ? new(p) ::FairGeoRotation : new ::FairGeoRotation;
   }
   static void *newArray_FairGeoRotation(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoRotation[nElements] : new ::FairGeoRotation[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoRotation(void *p) {
      delete ((::FairGeoRotation*)p);
   }
   static void deleteArray_FairGeoRotation(void *p) {
      delete [] ((::FairGeoRotation*)p);
   }
   static void destruct_FairGeoRotation(void *p) {
      typedef ::FairGeoRotation current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoRotation(TBuffer &buf, void *obj) {
      ((::FairGeoRotation*)obj)->::FairGeoRotation::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoRotation

//______________________________________________________________________________
void FairGeoTransform::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoTransform.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      rot.Streamer(R__b);
      trans.Streamer(R__b);
      trans_cm.Streamer(R__b);
      R__b.CheckByteCount(R__s, R__c, FairGeoTransform::IsA());
   } else {
      R__c = R__b.WriteVersion(FairGeoTransform::IsA(), kTRUE);
      TObject::Streamer(R__b);
      rot.Streamer(R__b);
      trans.Streamer(R__b);
      trans_cm.Streamer(R__b);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoTransform(void *p) {
      return  p ? new(p) ::FairGeoTransform : new ::FairGeoTransform;
   }
   static void *newArray_FairGeoTransform(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoTransform[nElements] : new ::FairGeoTransform[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoTransform(void *p) {
      delete ((::FairGeoTransform*)p);
   }
   static void deleteArray_FairGeoTransform(void *p) {
      delete [] ((::FairGeoTransform*)p);
   }
   static void destruct_FairGeoTransform(void *p) {
      typedef ::FairGeoTransform current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoTransform(TBuffer &buf, void *obj) {
      ((::FairGeoTransform*)obj)->::FairGeoTransform::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoTransform

//______________________________________________________________________________
void FairGeoVolume::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoVolume.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(FairGeoVolume::Class(),this);
   } else {
      R__b.WriteClassBuffer(FairGeoVolume::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoVolume(void *p) {
      return  p ? new(p) ::FairGeoVolume : new ::FairGeoVolume;
   }
   static void *newArray_FairGeoVolume(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoVolume[nElements] : new ::FairGeoVolume[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoVolume(void *p) {
      delete ((::FairGeoVolume*)p);
   }
   static void deleteArray_FairGeoVolume(void *p) {
      delete [] ((::FairGeoVolume*)p);
   }
   static void destruct_FairGeoVolume(void *p) {
      typedef ::FairGeoVolume current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FairGeoVolume

//______________________________________________________________________________
void FairGeoNode::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoNode.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(FairGeoNode::Class(),this);
   } else {
      R__b.WriteClassBuffer(FairGeoNode::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoNode(void *p) {
      return  p ? new(p) ::FairGeoNode : new ::FairGeoNode;
   }
   static void *newArray_FairGeoNode(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoNode[nElements] : new ::FairGeoNode[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoNode(void *p) {
      delete ((::FairGeoNode*)p);
   }
   static void deleteArray_FairGeoNode(void *p) {
      delete [] ((::FairGeoNode*)p);
   }
   static void destruct_FairGeoNode(void *p) {
      typedef ::FairGeoNode current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FairGeoNode

//______________________________________________________________________________
void FairGeoOldAsciiIo::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoOldAsciiIo.

   FairGeoIo::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoOldAsciiIo(void *p) {
      return  p ? new(p) ::FairGeoOldAsciiIo : new ::FairGeoOldAsciiIo;
   }
   static void *newArray_FairGeoOldAsciiIo(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoOldAsciiIo[nElements] : new ::FairGeoOldAsciiIo[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoOldAsciiIo(void *p) {
      delete ((::FairGeoOldAsciiIo*)p);
   }
   static void deleteArray_FairGeoOldAsciiIo(void *p) {
      delete [] ((::FairGeoOldAsciiIo*)p);
   }
   static void destruct_FairGeoOldAsciiIo(void *p) {
      typedef ::FairGeoOldAsciiIo current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoOldAsciiIo(TBuffer &buf, void *obj) {
      ((::FairGeoOldAsciiIo*)obj)->::FairGeoOldAsciiIo::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoOldAsciiIo

//______________________________________________________________________________
void FairGeoPcon::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoPcon.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoPcon(void *p) {
      return  p ? new(p) ::FairGeoPcon : new ::FairGeoPcon;
   }
   static void *newArray_FairGeoPcon(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoPcon[nElements] : new ::FairGeoPcon[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoPcon(void *p) {
      delete ((::FairGeoPcon*)p);
   }
   static void deleteArray_FairGeoPcon(void *p) {
      delete [] ((::FairGeoPcon*)p);
   }
   static void destruct_FairGeoPcon(void *p) {
      typedef ::FairGeoPcon current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoPcon(TBuffer &buf, void *obj) {
      ((::FairGeoPcon*)obj)->::FairGeoPcon::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoPcon

//______________________________________________________________________________
void FairGeoPgon::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoPgon.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoPgon(void *p) {
      return  p ? new(p) ::FairGeoPgon : new ::FairGeoPgon;
   }
   static void *newArray_FairGeoPgon(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoPgon[nElements] : new ::FairGeoPgon[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoPgon(void *p) {
      delete ((::FairGeoPgon*)p);
   }
   static void deleteArray_FairGeoPgon(void *p) {
      delete [] ((::FairGeoPgon*)p);
   }
   static void destruct_FairGeoPgon(void *p) {
      typedef ::FairGeoPgon current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoPgon(TBuffer &buf, void *obj) {
      ((::FairGeoPgon*)obj)->::FairGeoPgon::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoPgon

//______________________________________________________________________________
void FairGeoRootBuilder::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoRootBuilder.

   FairGeoBuilder::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoRootBuilder(void *p) {
      return  p ? new(p) ::FairGeoRootBuilder : new ::FairGeoRootBuilder;
   }
   static void *newArray_FairGeoRootBuilder(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoRootBuilder[nElements] : new ::FairGeoRootBuilder[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoRootBuilder(void *p) {
      delete ((::FairGeoRootBuilder*)p);
   }
   static void deleteArray_FairGeoRootBuilder(void *p) {
      delete [] ((::FairGeoRootBuilder*)p);
   }
   static void destruct_FairGeoRootBuilder(void *p) {
      typedef ::FairGeoRootBuilder current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoRootBuilder(TBuffer &buf, void *obj) {
      ((::FairGeoRootBuilder*)obj)->::FairGeoRootBuilder::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoRootBuilder

//______________________________________________________________________________
void FairGeoSet::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoSet.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_FairGeoSet(void *p) {
      delete ((::FairGeoSet*)p);
   }
   static void deleteArray_FairGeoSet(void *p) {
      delete [] ((::FairGeoSet*)p);
   }
   static void destruct_FairGeoSet(void *p) {
      typedef ::FairGeoSet current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoSet(TBuffer &buf, void *obj) {
      ((::FairGeoSet*)obj)->::FairGeoSet::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoSet

//______________________________________________________________________________
void FairGeoShapes::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoShapes.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoShapes(void *p) {
      return  p ? new(p) ::FairGeoShapes : new ::FairGeoShapes;
   }
   static void *newArray_FairGeoShapes(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoShapes[nElements] : new ::FairGeoShapes[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoShapes(void *p) {
      delete ((::FairGeoShapes*)p);
   }
   static void deleteArray_FairGeoShapes(void *p) {
      delete [] ((::FairGeoShapes*)p);
   }
   static void destruct_FairGeoShapes(void *p) {
      typedef ::FairGeoShapes current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoShapes(TBuffer &buf, void *obj) {
      ((::FairGeoShapes*)obj)->::FairGeoShapes::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoShapes

//______________________________________________________________________________
void FairGeoSphe::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoSphe.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoSphe(void *p) {
      return  p ? new(p) ::FairGeoSphe : new ::FairGeoSphe;
   }
   static void *newArray_FairGeoSphe(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoSphe[nElements] : new ::FairGeoSphe[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoSphe(void *p) {
      delete ((::FairGeoSphe*)p);
   }
   static void deleteArray_FairGeoSphe(void *p) {
      delete [] ((::FairGeoSphe*)p);
   }
   static void destruct_FairGeoSphe(void *p) {
      typedef ::FairGeoSphe current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoSphe(TBuffer &buf, void *obj) {
      ((::FairGeoSphe*)obj)->::FairGeoSphe::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoSphe

//______________________________________________________________________________
void FairGeoTrap::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoTrap.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoTrap(void *p) {
      return  p ? new(p) ::FairGeoTrap : new ::FairGeoTrap;
   }
   static void *newArray_FairGeoTrap(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoTrap[nElements] : new ::FairGeoTrap[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoTrap(void *p) {
      delete ((::FairGeoTrap*)p);
   }
   static void deleteArray_FairGeoTrap(void *p) {
      delete [] ((::FairGeoTrap*)p);
   }
   static void destruct_FairGeoTrap(void *p) {
      typedef ::FairGeoTrap current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoTrap(TBuffer &buf, void *obj) {
      ((::FairGeoTrap*)obj)->::FairGeoTrap::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoTrap

//______________________________________________________________________________
void FairGeoTrd1::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoTrd1.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoTrd1(void *p) {
      return  p ? new(p) ::FairGeoTrd1 : new ::FairGeoTrd1;
   }
   static void *newArray_FairGeoTrd1(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoTrd1[nElements] : new ::FairGeoTrd1[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoTrd1(void *p) {
      delete ((::FairGeoTrd1*)p);
   }
   static void deleteArray_FairGeoTrd1(void *p) {
      delete [] ((::FairGeoTrd1*)p);
   }
   static void destruct_FairGeoTrd1(void *p) {
      typedef ::FairGeoTrd1 current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoTrd1(TBuffer &buf, void *obj) {
      ((::FairGeoTrd1*)obj)->::FairGeoTrd1::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoTrd1

//______________________________________________________________________________
void FairGeoTube::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoTube.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoTube(void *p) {
      return  p ? new(p) ::FairGeoTube : new ::FairGeoTube;
   }
   static void *newArray_FairGeoTube(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoTube[nElements] : new ::FairGeoTube[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoTube(void *p) {
      delete ((::FairGeoTube*)p);
   }
   static void deleteArray_FairGeoTube(void *p) {
      delete [] ((::FairGeoTube*)p);
   }
   static void destruct_FairGeoTube(void *p) {
      typedef ::FairGeoTube current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoTube(TBuffer &buf, void *obj) {
      ((::FairGeoTube*)obj)->::FairGeoTube::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoTube

//______________________________________________________________________________
void FairGeoTubs::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoTubs.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoTubs(void *p) {
      return  p ? new(p) ::FairGeoTubs : new ::FairGeoTubs;
   }
   static void *newArray_FairGeoTubs(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoTubs[nElements] : new ::FairGeoTubs[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoTubs(void *p) {
      delete ((::FairGeoTubs*)p);
   }
   static void deleteArray_FairGeoTubs(void *p) {
      delete [] ((::FairGeoTubs*)p);
   }
   static void destruct_FairGeoTubs(void *p) {
      typedef ::FairGeoTubs current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoTubs(TBuffer &buf, void *obj) {
      ((::FairGeoTubs*)obj)->::FairGeoTubs::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoTubs

//______________________________________________________________________________
void FairGeoTorus::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoTorus.

   FairGeoBasicShape::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoTorus(void *p) {
      return  p ? new(p) ::FairGeoTorus : new ::FairGeoTorus;
   }
   static void *newArray_FairGeoTorus(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoTorus[nElements] : new ::FairGeoTorus[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoTorus(void *p) {
      delete ((::FairGeoTorus*)p);
   }
   static void deleteArray_FairGeoTorus(void *p) {
      delete [] ((::FairGeoTorus*)p);
   }
   static void destruct_FairGeoTorus(void *p) {
      typedef ::FairGeoTorus current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoTorus(TBuffer &buf, void *obj) {
      ((::FairGeoTorus*)obj)->::FairGeoTorus::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoTorus

//______________________________________________________________________________
void FairGeoCompositeVolume::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoCompositeVolume.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      FairGeoVolume::Streamer(R__b);
      R__b >> components;
      R__b.CheckByteCount(R__s, R__c, FairGeoCompositeVolume::IsA());
   } else {
      R__c = R__b.WriteVersion(FairGeoCompositeVolume::IsA(), kTRUE);
      FairGeoVolume::Streamer(R__b);
      R__b << components;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoCompositeVolume(void *p) {
      return  p ? new(p) ::FairGeoCompositeVolume : new ::FairGeoCompositeVolume;
   }
   static void *newArray_FairGeoCompositeVolume(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoCompositeVolume[nElements] : new ::FairGeoCompositeVolume[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoCompositeVolume(void *p) {
      delete ((::FairGeoCompositeVolume*)p);
   }
   static void deleteArray_FairGeoCompositeVolume(void *p) {
      delete [] ((::FairGeoCompositeVolume*)p);
   }
   static void destruct_FairGeoCompositeVolume(void *p) {
      typedef ::FairGeoCompositeVolume current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoCompositeVolume(TBuffer &buf, void *obj) {
      ((::FairGeoCompositeVolume*)obj)->::FairGeoCompositeVolume::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoCompositeVolume

//______________________________________________________________________________
void FairGeoAsciiIo::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoAsciiIo.

   FairGeoIo::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_FairGeoAsciiIo(void *p) {
      return  p ? new(p) ::FairGeoAsciiIo : new ::FairGeoAsciiIo;
   }
   static void *newArray_FairGeoAsciiIo(Long_t nElements, void *p) {
      return p ? new(p) ::FairGeoAsciiIo[nElements] : new ::FairGeoAsciiIo[nElements];
   }
   // Wrapper around operator delete
   static void delete_FairGeoAsciiIo(void *p) {
      delete ((::FairGeoAsciiIo*)p);
   }
   static void deleteArray_FairGeoAsciiIo(void *p) {
      delete [] ((::FairGeoAsciiIo*)p);
   }
   static void destruct_FairGeoAsciiIo(void *p) {
      typedef ::FairGeoAsciiIo current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_FairGeoAsciiIo(TBuffer &buf, void *obj) {
      ((::FairGeoAsciiIo*)obj)->::FairGeoAsciiIo::Streamer(buf);
   }
} // end of namespace ROOT for class ::FairGeoAsciiIo

//______________________________________________________________________________
void FairGeoBrik::Streamer(TBuffer &R__b)
{
   // Stream an object of class FairGeoBrik.

   FairGeoBasicShape::Streamer(R__b);
}

